name: Go CI/CD Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ] # Run on version tags like v1.0.0
  pull_request:
    branches: [ main ]

permissions:
  contents: write # Needed to write Releases
  pull-requests: read # Needed for govulncheck-action potentially on PRs
  checks: write # Needed for govulncheck-action potentially

jobs:
  validate:
    name: Validate Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod tidy
        # Optional: check if go.mod/go.sum changed and fail if so
        # run: |
        #   go mod tidy
        #   if ! git diff --exit-code -- go.mod go.sum; then
        #     echo "::error::go.mod/go.sum are outdated, run 'go mod tidy' locally and commit"
        #     exit 1
        #   fi

      # Optional: Add Linting (Example using golangci-lint)
      # - name: Run golangci-lint
      #   uses: golangci/golangci-lint-action@v6
      #   with:
      #     version: latest
      #     args: --timeout=5m

      # Optional: Add Tests (Uncomment if you have tests)
      # - name: Run tests
      #   run: go test -v ./...

      # --- CORRECTED GOVULNCHECK STEP ---
      - name: Run govulncheck
        # Use the dedicated action which handles installation
        uses: golang/govulncheck-action@v1
        # Action defaults to checking ./... using the Go version set up previously
      # --- END CORRECTED STEP ---


  build_binaries:
    name: Build Binaries
    # Only run this job on tag pushes
    if: startsWith(github.ref, 'refs/tags/v')
    needs: validate # Run only if the validate job succeeds
    runs-on: ${{ matrix.os }} # Run builds on the target OS
    strategy:
      fail-fast: false # Prevent cancelling all matrix jobs if one fails
      matrix:
        include:
          - name: linux-amd64
            os: ubuntu-latest
            goos: linux
            goarch: amd64
          - name: linux-arm64
            os: ubuntu-latest
            goos: linux
            goarch: arm64
          - name: darwin-amd64 # macOS
            os: macos-latest
            goos: darwin
            goarch: amd64
          - name: darwin-arm64 # macOS
            os: macos-latest
            goos: darwin
            goarch: arm64
          - name: windows-amd64
            os: windows-latest
            goos: windows
            goarch: amd64
            ext: .exe
            # Add other os/arch if needed

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod tidy

      - name: Build application (${{ matrix.name }})
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
          BINARY_NAME: git-monitor-${{ matrix.name }}${{ matrix.ext }}
        run: |
          echo "Building for $GOOS/$GOARCH..."
          mkdir -p dist # Ensure dist directory exists
          go build -v -trimpath -ldflags="-s -w" -o "dist/$BINARY_NAME" .
          echo "Built: dist/$BINARY_NAME"

      # --- CORRECTED ARCHIVE STEP ---
      - name: Create Archive (${{ matrix.name }})
        id: archive
        shell: bash # Use bash for consistency
        run: |
          ARTIFACT_NAME="git-monitor-${{ github.ref_name }}-${{ matrix.name }}"
          ARCHIVE_PATH="" # Initialize variable
          # Check if dist directory exists and has content before archiving
          if [ -d "dist" ] && [ -n "$(ls -A dist)" ]; then
            echo "Archiving contents of dist/ for ${{ matrix.name }}"
            if [[ "${{ matrix.goos }}" == "windows" ]]; then
              # Create archive in the current directory (workspace root) containing files from ./dist/
              7z a "${ARTIFACT_NAME}.zip" "./dist/*"
              ARCHIVE_PATH="${ARTIFACT_NAME}.zip" # Path relative to workspace root
              echo "Created ${ARCHIVE_PATH}"
            else
              # Create archive in the current directory (workspace root) containing files from ./dist/
              # Use -C flag for tar to change directory only for the operation
              tar czvf "${ARTIFACT_NAME}.tar.gz" -C dist . # The '.' means all files relative to '-C dist'
              ARCHIVE_PATH="${ARTIFACT_NAME}.tar.gz" # Path relative to workspace root
              echo "Created ${ARCHIVE_PATH}"
            fi
          else
            echo "::warning::Directory dist/ is empty or does not exist. Skipping archive creation for ${{ matrix.name }}."
            ARCHIVE_PATH=""
          fi
          # Set output for artifact upload step (path is now relative to workspace root)
          echo "archive_path=${ARCHIVE_PATH}" >> $GITHUB_OUTPUT
      # --- END CORRECTED ARCHIVE STEP ---

      - name: Upload build artifact (${{ matrix.name }})
        # Only run if archive_path is not empty
        if: steps.archive.outputs.archive_path != ''
        uses: actions/upload-artifact@v4
        with:
          name: git-monitor-binaries-${{ matrix.name }} # Unique artifact name per build
          # Path is now directly the archive name in the workspace root
          path: ${{ steps.archive.outputs.archive_path }}
          retention-days: 5 # Keep artifacts for 5 days


  create_upload_release:
    name: Create GitHub Release
    # Only run this job on tag pushes
    if: startsWith(github.ref, 'refs/tags/v')
    needs: build_binaries # Run after all matrix builds are done
    runs-on: ubuntu-latest
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts # Download to ./artifacts directory (creates subdirs per artifact)

      - name: List downloaded artifacts (for debugging)
        run: |
          echo "Listing downloaded artifacts..."
          find ./artifacts -type f # List all files found

      - name: Create GitHub Release and Upload Assets
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          body: |
            Automated release for version ${{ github.ref_name }}

            **Binaries:**
            (Attached below)
          draft: false
          prerelease: false
          # This pattern uploads all files within the subdirectories created by download-artifact
          files: |
            ./artifacts/*/*